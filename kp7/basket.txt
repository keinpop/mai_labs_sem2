?vector.h?################################
#ifndef __VECTOR_H__
#define __VECTOR_H__

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef double Item;

typedef struct _vector {
    int* begin;
    int size;
    int allocated;
} Vector;

typedef struct _vector_m {
    int* begin;
    int size;
    int allocated;
} VecM;

typedef struct _element_a { // _vector_a
    int value;
    int column;
    int index_next;
} ElementA;

typedef struct _vector_a {
    ElementA* begin;
    int size;
    int allocated;
} VecA;


void readFile(FILE* file);
void createV(Vector* v); // Создание вектора
void createVA(VecA* va); // Создание вектора А
void createVM(VecM* vm); // Создание вектора M

void deleteV(Vector* v);
void deleteVA(VecA* va);
void deleteVM(VecM* vm);

void pushBackV(Vector* v, int value);
void insertValueVecA(VecA* va, int column, int value, int index);
void insertValueVecM(VecM* vm, int value);

void printV(Vector* v);
void printVA(VecA* va);
void printVM(VecM* vm);

VecA copyFrom(VecA* va);

int sizeV(Vector* v);

#endif // __VECTOR_H__

?vector.c?#######################################################################
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "vector.h"

void readFile(FILE* file) {

    int m = 0, n = 0; // Переменные колличества строк и столбцов
    fscanf(file, "%d", &m);
    fscanf(file, "%d", &n);

    printf("%d - this i\n%d - this j\n", m, n);

    int element[m][n];
    for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                fscanf(file, "%d", &element[i][j]);
                if (element[i][j] != 0) {
                    printf("%d ", element[i][j]);
                }
            }
    }
    
    
    fclose(file);
}

void createV(Vector* v) {
    v->allocated = 1;
    v->size = 0;
    v->begin = malloc(v->allocated * sizeof(int));
}

void createVA(VecA* va) {
    va->allocated = 1;
    va->size = 0;
    va->begin = malloc(va->allocated * sizeof(ElementA));
}

void createVM(VecM* vm) {
    vm->allocated = 1;
    vm->size = 0;
    vm->begin = malloc(vm->allocated * sizeof(int));
}

void deleteV(Vector *v) {
    free(v->begin);
    v->allocated = 0;
    v->size = 0;
    v->begin = NULL;
}

void deleteVA(VecA* va) { // !!!ЗДЕСЬ ВОЗМОЖНА УТЕЧКА ПАМЯТИ!!!
    free(va->begin);
    va->allocated = 0;
    va->size = 0;
    va->begin = NULL;
}

void deleteVM(VecM* vm) {
    free(vm->begin);
    vm->allocated  = 0;
    vm->size = 0;
    vm->begin = NULL;
}

void pushBackV(Vector* v, int value) {
    if (v->size + 1 >= v->allocated) { // Проверка на необходимость выделения еще памяти
        v->allocated *= 2;
        v->begin = realloc(v->begin, sizeof(int) * v->allocated);
    }
    v->begin[v->size++] = value;
}

void insertValueVecA(VecA* va, int column, int value, int index) {
    if (va->size + 1 >= va->allocated) {
        va->allocated *= 2;
        va->begin = realloc(va->begin, sizeof(ElementA) * va->allocated);
    }
    va->begin[va->size].column = column;
    va->begin[va->size].value = value;
    va->begin[va->size].index_next = index;
    ++va->size;
}

void insertValueVecM(VecM* vm, int value) {
    if (vm->size + 1 >= vm->allocated) { // Проверка на необходимость выделения еще памяти
        vm->allocated *= 2;
        vm->begin = realloc(vm->begin, sizeof(int) * vm->allocated);
    }
    vm->begin[vm->size++] = value;
}

void printV(Vector* v) {
    for (int i = 0; i < v->size; i++) {
        printf("%d ", v->begin[i]);
    }
    printf("\n");
}

void printVA(VecA* va) {
    printf("Vector A = ");
    for (int i = 0; i < va->size; i++) {
        printf("(%d;", va->begin[i].column);
        printf("%d;", va->begin[i].value);
        printf("%d) ", va->begin[i].index_next);
    }
    printf("\n");
}

void printVM(VecM* vm) {
    printf("Vector M = ( ");
    for (int i = 0; i < vm->size; i++) {
        printf("%d ", vm->begin[i]);
    }
    printf(")\n");
}

VecA copyFrom(VecA* va) {
    VecA copyVa;
    createVA(&copyVa);
    for (int i = 0; i < va->size; i++) {
        insertValueVecA(&copyVa, va->begin[i].column, va->begin[i].value, va->begin[i].index_next);
    }
    return copyVa;
}

int sizeV(Vector* v) {
    return v->size;
}

?main.c?############################################
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include "vector.h"



// m - КОЛИЧЕСТВО СТРОК, n - КОЛИЧЕСТВО СТОЛБЦОВ!!!
void AddedElementVectorA(VecA* va) {
    printf("Enter filename:\n");
    char filename[50];
    scanf("%s", filename);
    
    FILE* file = fopen(filename, "r");

    int m, n;
    fscanf(file, "%d", &m); // Строка
    fscanf(file, "%d", &n); // Столбец

    for (int i = 0; i < m; i++) {
        int nonzero_count = 0; // Счетчик ненулевых элементов в текущей строке
        int last_inserted_index = -1; // Индекс последнего вставленного элемента

        for (int j = 0; j < n; j++) {
            int num;
            fscanf(file, "%d", &num);

            if (num != 0) {
                int column = j;
                int value = num;
                int index = -1;
                insertValueVecA(va, column, value, index);
                nonzero_count++;

                if (last_inserted_index != -1) {
                    va->begin[last_inserted_index].index_next = va->size - 1;
                }
                last_inserted_index = va->size - 1;
            }
        }

        if (nonzero_count == 0 && last_inserted_index != -1) {
            va->begin[last_inserted_index].index_next = -1;
        }
    }

    fclose(file);
}

void AddedElementVectorM(VecM* vm, VecA* va) {
    printf("Enter filename:\n");
    char filename[50];
    scanf("%s", filename);

    FILE* file = fopen(filename, "r");

    int m, n;
    fscanf(file, "%d", &m); // Строка
    fscanf(file, "%d", &n); // Столбец
    VecA copyVa = copyFrom(va);
    for (int i = 0; i < m; i++) {
        int check = 0; // Сбросить check в ноль перед каждой строкой

        int tmp_num = 0;
        for (int j = 0; j < n; j++) {
            int num;
            fscanf(file, "%d", &num);
            if (num != 0 && check == 0) { // Добавить условие, чтобы сохранять только первый ненулевой элемент
                tmp_num = num;
                check = 1;
            }
        }

        if (check == 0) {
            insertValueVecM(vm, -1);
        } else {
            int foundIndex = -1;
            for (int k = 0; k < copyVa.size; k++) {
                if (tmp_num == copyVa.begin[k].value && copyVa.begin[k].column != -1) {
                    foundIndex = k;
                    copyVa.begin[k].column = -1;
                    break; // Добавить прерывание цикла, чтобы сохранять только первое совпадение
                }
            }
            if (foundIndex != -1) {
                insertValueVecM(vm, foundIndex);
            }
        }
    }

    fclose(file);
}

void printSparceMatrix(VecA* va, VecM* vm) {
    printf("Enter filename:\n");
    char filename[50];
    scanf("%s", filename);

    FILE* file_in = fopen(filename, "r");

    int m, n;
    fscanf(file_in, "%d", &m); // Строка
    fscanf(file_in, "%d", &n); // Столбец

    FILE* file_out = fopen("out.txt", "a");

    for (int i = 0; i < m; i++) {
        bool checkIndexM = false;
        int IndexM = -1;
        if (vm->begin[i] != -1) {
            checkIndexM = true;
            IndexM = vm->begin[i];
        }
        int count = 0;
        for (int k = IndexM; k != -1; k = va->begin[k].index_next) {
            count++;
        }
        int nextIndex = IndexM;
        for (int j = 0; j < n; j++) {
            if (nextIndex != -1 && va->begin[nextIndex].column == j) {
                fprintf(file_out, "%d ", va->begin[nextIndex].value);
                nextIndex = va->begin[nextIndex].index_next;
            } else {
                fprintf(file_out, "0 ");
            }
        }
        fprintf(file_out, "\n");
    }

    fclose(file_in);
    fclose(file_out);
}


int main() 
{
    // readFile();
    // printf("Enter filename:\n");
    // char filename[50];
    // scanf("%s", filename);
    
    // FILE* file = fopen(filename, "r");


    VecA vectorA;
    VecM vectorM;
    createVA(&vectorA);
    createVM(&vectorM);

    AddedElementVectorA(&vectorA);
    AddedElementVectorM(&vectorM, &vectorA);
    printVA(&vectorA);
    printVM(&vectorM);
    printSparceMatrix(&vectorA,&vectorM);
    

    deleteVA(&vectorA);
    deleteVM(&vectorM);

    return 0;
}

Старый ввод:
6 10
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 5 0 0
0 2 0 0 0 3 0 0 6 0
0 0 0 0 0 0 0 0 0 0
2 3 0 0 0 0 0 0 4 0

Новый ввод:
6 10
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
0.0 0.0 0.0 0.0 1.0 0.0 0.0 5.0 0.0 0.0
0.0 2.0 0.0 0.0 0.0 3.0 0.0 0.0 6.0 0.0
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
2.0 3.0 0.0 0.0 0.0 0.0 0.0 0.0 4.0 0.0

Большой ввод:
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.3 0.0 0.0 0.0 0.5 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.3 0.5 0.0 0.0 0.0 0.0 0.0 0.0 0.7 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.3 0.0 0.0 0.0 0.5 0.0 0.0 1.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.3 0.5 0.0 0.0 0.0 0.0 0.0 0.0 0.7 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.2 0.0 0.0 0.8 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 

void createFile(FILE* file) {
    file = fopen(file, "a"); // Открыть файл на чтение
    if (file != NULL) {
        fclose(file);
    }
}

void deleteStudent(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("File not found\n");
        return;
    }
    printf("Enter student surname:\n");
    char surname[100];
    scanf("%s", surname);
    if (!file) {
        return;
    }  
    char tmp_name[100];
    FILE* tmp_file;
    int name_lenght = strlen(filename);
    strcpy(tmp_name, filename);
    tmp_name[name_lenght] = '_';
    tmp_name[name_lenght + 1] = '\0';
    tmp_file = fopen(tmp_name, "ab");
    if (!tmp_file) {
        printf("fopen failed, errno = %d\n", errno);
        return;
    }

    pc row;
    while (studentReadBin(&row, file)) {
        if (strcmp(row.surname, surname) != 0) {
            studentWriteBin(&row, tmp_file);
        }
        memset(&row, 0, sizeof(pc));
    }
    fclose(tmp_file);
    fclose(file);
    
    remove(file);
    rename(tmp_name, filename);
}
